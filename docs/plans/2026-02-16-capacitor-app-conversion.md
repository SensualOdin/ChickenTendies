# ChickenTinders Capacitor App Conversion

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Convert the existing React PWA into native iOS and Android apps using Capacitor, ready for App Store and Play Store submission.

**Architecture:** Wrap the existing Vite-built React web app in a Capacitor native shell. The backend stays unchanged on Render. Native plugins replace web APIs for geolocation, push notifications, haptics, sharing, and external links. A platform detection utility ensures the same codebase works on web and native.

**Tech Stack:** Capacitor 6, @capacitor/ios, @capacitor/android, @capacitor/haptics, @capacitor/push-notifications, @capacitor/geolocation, @capacitor/share, @capacitor/browser, @capacitor/app, @capacitor/status-bar, @capacitor/splash-screen, @capacitor/keyboard

---

### Task 1: Initialize Capacitor in the project

Install Capacitor core and CLI, create the config file pointing to the Render backend.

**Files:**
- Create: `capacitor.config.ts`
- Modify: `package.json`

**Step 1: Install Capacitor**

```bash
npm install @capacitor/core @capacitor/cli
npx cap init ChickenTinders com.chickentinders.app --web-dir dist/public
```

This creates `capacitor.config.ts`. The `--web-dir` flag tells Capacitor where the built web assets live (Vite outputs to `dist/public`).

**Step 2: Update capacitor.config.ts**

Replace the generated config with:

```typescript
import type { CapacitorConfig } from "@capacitor/core";

const config: CapacitorConfig = {
  appId: "com.chickentinders.app",
  appName: "ChickenTinders",
  webDir: "dist/public",
  server: {
    // In production, the app loads from bundled files.
    // The API URL points to your Render backend.
    url: process.env.NODE_ENV === "development" ? "http://localhost:5000" : undefined,
    androidScheme: "https",
    iosScheme: "https",
  },
  plugins: {
    SplashScreen: {
      launchAutoHide: true,
      launchShowDuration: 2000,
      backgroundColor: "#1a1a2e",
      showSpinner: false,
    },
    Keyboard: {
      resize: "body",
      style: "dark",
    },
    PushNotifications: {
      presentationOptions: ["badge", "sound", "alert"],
    },
  },
};

export default config;
```

**Step 3: Add npm scripts**

Add these scripts to `package.json`:

```json
"cap:sync": "npx cap sync",
"cap:open:ios": "npx cap open ios",
"cap:open:android": "npx cap open android",
"cap:build": "npm run build && npx cap sync"
```

**Step 4: Commit**

```bash
git add capacitor.config.ts package.json package-lock.json
git commit -m "feat: initialize Capacitor for native app conversion"
```

---

### Task 2: Add iOS and Android platforms

Install the native platform packages and generate the Xcode and Android Studio projects.

**Files:**
- Create: `ios/` (generated by Capacitor)
- Create: `android/` (generated by Capacitor)
- Modify: `.gitignore`

**Step 1: Build web assets first**

```bash
npm run build
```

This generates `dist/public/` which Capacitor needs to copy into the native projects.

**Step 2: Add platforms**

```bash
npm install @capacitor/ios @capacitor/android
npx cap add ios
npx cap add android
```

This creates the `ios/` and `android/` directories with Xcode and Android Studio projects.

**Step 3: Update .gitignore**

Add native build artifacts to `.gitignore` (keep the projects themselves in git):

```
# Capacitor native build artifacts
ios/App/Pods/
ios/DerivedData/
android/.gradle/
android/build/
android/app/build/
android/local.properties
```

**Step 4: Sync and verify**

```bash
npx cap sync
```

This copies `dist/public/` into both native projects and installs CocoaPods for iOS.

**Step 5: Commit**

```bash
git add ios/ android/ .gitignore package.json package-lock.json
git commit -m "feat: add iOS and Android native platforms"
```

---

### Task 3: Create platform detection utility

Create a utility to detect whether the app is running on web, iOS, or Android. This lets every feature gracefully adapt.

**Files:**
- Create: `client/src/lib/platform.ts`

**Step 1: Create the platform utility**

```typescript
import { Capacitor } from "@capacitor/core";

export type Platform = "web" | "ios" | "android";

export function getPlatform(): Platform {
  if (Capacitor.isNativePlatform()) {
    return Capacitor.getPlatform() as "ios" | "android";
  }
  return "web";
}

export function isNative(): boolean {
  return Capacitor.isNativePlatform();
}

export function isIOS(): boolean {
  return Capacitor.getPlatform() === "ios";
}

export function isAndroid(): boolean {
  return Capacitor.getPlatform() === "android";
}

export function isWeb(): boolean {
  return !Capacitor.isNativePlatform();
}
```

**Step 2: Commit**

```bash
git add client/src/lib/platform.ts
git commit -m "feat: add platform detection utility for web/iOS/Android"
```

---

### Task 4: Configure API base URL for native

On web, API calls go to the same origin (`VITE_API_URL` is empty). On native, the app runs from local files so API calls must target the Render backend URL explicitly.

**Files:**
- Modify: `client/src/lib/queryClient.ts`

**Step 1: Update API_BASE to handle native**

Replace the existing `API_BASE` line:

```typescript
export const API_BASE = import.meta.env.VITE_API_URL || "";
```

With:

```typescript
import { isNative } from "./platform";

// On native, app runs from local files so we need the full backend URL.
// On web, API calls go to the same origin.
export const API_BASE = isNative()
  ? (import.meta.env.VITE_PRODUCTION_API_URL || "https://chickentinders.onrender.com")
  : (import.meta.env.VITE_API_URL || "");
```

Also update the WebSocket URLs. Search for any `ws://` or `wss://` construction in the codebase (in `client/src/pages/swipe.tsx` and `client/src/pages/group-lobby.tsx`) and ensure they use the same base URL logic. The WebSocket connection currently uses:

```typescript
const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
const wsUrl = `${wsProtocol}//${window.location.host}/ws?...`;
```

Replace with:

```typescript
import { isNative } from "@/lib/platform";

const wsBase = isNative()
  ? "wss://chickentinders.onrender.com"
  : `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${window.location.host}`;
const wsUrl = `${wsBase}/ws?...`;
```

Apply this pattern to both `swipe.tsx` and `group-lobby.tsx`.

**Step 2: Add env variable to .env.example or capacitor config**

Ensure `VITE_PRODUCTION_API_URL` is documented. You can also hardcode it in `capacitor.config.ts` if preferred.

**Step 3: Commit**

```bash
git add client/src/lib/queryClient.ts client/src/pages/swipe.tsx client/src/pages/group-lobby.tsx
git commit -m "feat: configure API base URL for native platform"
```

---

### Task 5: Install and integrate native plugins

Install all the Capacitor plugins needed for native features.

**Files:**
- Modify: `package.json`

**Step 1: Install all plugins**

```bash
npm install @capacitor/haptics @capacitor/push-notifications @capacitor/geolocation @capacitor/share @capacitor/browser @capacitor/app @capacitor/status-bar @capacitor/splash-screen @capacitor/keyboard
```

**Step 2: Sync native projects**

```bash
npx cap sync
```

This registers the plugins with the native projects (updates iOS Podfile, Android gradle).

**Step 3: Commit**

```bash
git add package.json package-lock.json ios/ android/
git commit -m "feat: install Capacitor native plugins"
```

---

### Task 6: Add haptic feedback to swipe gestures

Add satisfying haptic feedback when swiping cards (like, dislike, superlike).

**Files:**
- Modify: `client/src/components/swipe-card.tsx`

**Step 1: Add haptic feedback to handleDragEnd**

At the top of the file, add:

```typescript
import { isNative } from "@/lib/platform";
import { Haptics, ImpactStyle, NotificationType } from "@capacitor/haptics";
```

Replace the existing `handleDragEnd` function (around line 49-60):

```typescript
const handleDragEnd = async (_: unknown, info: PanInfo) => {
  if (info.offset.y < -100) {
    setExitY(-400);
    if (isNative()) {
      await Haptics.notification({ type: NotificationType.Success });
    }
    onSwipe("superlike");
  } else if (info.offset.x > 100) {
    setExitX(300);
    if (isNative()) {
      await Haptics.impact({ style: ImpactStyle.Medium });
    }
    onSwipe("like");
  } else if (info.offset.x < -100) {
    setExitX(-300);
    if (isNative()) {
      await Haptics.impact({ style: ImpactStyle.Light });
    }
    onSwipe("dislike");
  }
};
```

This gives:
- **Like**: medium impact (satisfying thud)
- **Dislike**: light impact (subtle dismissal)
- **Superlike**: success notification (distinct pattern)

**Step 2: Commit**

```bash
git add client/src/components/swipe-card.tsx
git commit -m "feat: add haptic feedback to swipe gestures"
```

---

### Task 7: Replace navigator.geolocation with Capacitor Geolocation

Capacitor's geolocation plugin is more reliable on native (proper permission prompts, better accuracy).

**Files:**
- Modify: `client/src/pages/preferences.tsx`

**Step 1: Update the handleFindMe function**

At the top of the file, add:

```typescript
import { isNative } from "@/lib/platform";
import { Geolocation } from "@capacitor/geolocation";
```

Replace the `handleFindMe` function body (lines 165-211):

```typescript
const handleFindMe = async () => {
  setIsLocating(true);

  try {
    let latitude: number;
    let longitude: number;

    if (isNative()) {
      // Native: use Capacitor Geolocation (handles permissions natively)
      const position = await Geolocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: 10000,
      });
      latitude = position.coords.latitude;
      longitude = position.coords.longitude;
    } else {
      // Web: use browser geolocation
      if (!navigator.geolocation) {
        toast({
          title: "GPS not available",
          description: "Your browser doesn't support location services.",
          variant: "destructive",
        });
        setIsLocating(false);
        return;
      }

      const position = await new Promise<GeolocationPosition>((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 10000,
        });
      });
      latitude = position.coords.latitude;
      longitude = position.coords.longitude;
    }

    form.setValue("latitude", latitude);
    form.setValue("longitude", longitude);

    // Try to get a readable address using reverse geocoding
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json`,
        { headers: { "Accept": "application/json" } }
      );
      if (!response.ok) throw new Error("Geocoding failed");
      const data = await response.json();
      const address = data.address;
      if (address) {
        const locationName = address.neighbourhood || address.suburb || address.city || address.town || "Current Location";
        const postcode = address.postcode ? `, ${address.postcode}` : "";
        form.setValue("zipCode", `${locationName}${postcode}`);
      } else {
        form.setValue("zipCode", "Current Location");
      }
    } catch {
      form.setValue("zipCode", "Current Location");
    }

    setUsingGPS(true);
    setIsLocating(false);
    toast({
      title: "Location found!",
      description: "We'll search for restaurants near you.",
    });
  } catch (error: any) {
    setIsLocating(false);
    const message = error?.code === 1 || error?.message?.includes("denied")
      ? "Please allow location access in your device settings."
      : "Try entering your address manually.";
    toast({
      title: "Couldn't get location",
      description: message,
      variant: "destructive",
    });
  }
};
```

**Step 2: Commit**

```bash
git add client/src/pages/preferences.tsx
git commit -m "feat: use Capacitor Geolocation on native, browser geolocation on web"
```

---

### Task 8: Replace web push with native push notifications

On native, we need APNs (iOS) and FCM (Android) instead of web push. The Capacitor Push Notifications plugin handles both.

**Files:**
- Modify: `client/src/hooks/use-push-notifications.ts`

**Step 1: Rewrite usePushNotifications to support native**

Replace the entire file:

```typescript
import { useState, useEffect, useCallback } from "react";
import { useAuth } from "./use-auth";
import { apiRequest } from "@/lib/queryClient";
import { isNative } from "@/lib/platform";
import { PushNotifications } from "@capacitor/push-notifications";

type PermissionState = "default" | "granted" | "denied" | "unsupported";

function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

export function usePushNotifications() {
  const { isAuthenticated } = useAuth();
  const [permission, setPermission] = useState<PermissionState>("default");
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [vapidKey, setVapidKey] = useState<string | null>(null);

  const isPushSupported = isNative() || (
    typeof window !== "undefined" &&
    "serviceWorker" in navigator &&
    "PushManager" in window
  );

  useEffect(() => {
    if (!isPushSupported) {
      setPermission("unsupported");
      return;
    }

    if (isNative()) {
      // Check native push permission status
      PushNotifications.checkPermissions().then(({ receive }) => {
        if (receive === "granted") setPermission("granted");
        else if (receive === "denied") setPermission("denied");
        else setPermission("default");
      });

      // Listen for registration success
      PushNotifications.addListener("registration", async (token) => {
        setIsSubscribed(true);
        // Send the native push token to our backend
        try {
          await apiRequest("POST", "/api/push/subscribe-native", {
            token: token.value,
            platform: (await import("@/lib/platform")).getPlatform(),
          });
        } catch (err) {
          console.error("Failed to register native push token:", err);
        }
      });

      // Listen for registration errors
      PushNotifications.addListener("registrationError", (err) => {
        console.error("Native push registration failed:", err);
      });

      return () => {
        PushNotifications.removeAllListeners();
      };
    } else {
      // Web push setup (existing logic)
      setPermission(Notification.permission as PermissionState);

      fetch("/api/push/vapid-key")
        .then((res) => res.json())
        .then((data) => setVapidKey(data.publicKey))
        .catch(() => {});

      navigator.serviceWorker.ready.then((registration) => {
        registration.pushManager.getSubscription().then((subscription) => {
          setIsSubscribed(!!subscription);
        });
      });
    }
  }, [isPushSupported]);

  const subscribe = useCallback(async () => {
    if (!isPushSupported || !isAuthenticated) return false;

    setIsLoading(true);

    if (isNative()) {
      try {
        const permResult = await PushNotifications.requestPermissions();
        if (permResult.receive === "granted") {
          setPermission("granted");
          await PushNotifications.register();
          // Registration listener above will handle the rest
          setIsLoading(false);
          return true;
        } else {
          setPermission("denied");
          setIsLoading(false);
          return false;
        }
      } catch (error) {
        console.error("Native push error:", error);
        setIsLoading(false);
        return false;
      }
    }

    // Web push (existing logic)
    if (!vapidKey) {
      setIsLoading(false);
      return false;
    }

    try {
      const result = await Notification.requestPermission();
      setPermission(result as PermissionState);

      if (result !== "granted") {
        setIsLoading(false);
        return false;
      }

      const registration = await navigator.serviceWorker.register("/sw.js");
      await navigator.serviceWorker.ready;

      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(vapidKey),
      });

      const subscriptionJson = subscription.toJSON();
      await apiRequest("POST", "/api/push/subscribe", {
        endpoint: subscriptionJson.endpoint,
        keys: subscriptionJson.keys,
      });

      setIsSubscribed(true);
      setIsLoading(false);
      return true;
    } catch (error) {
      console.error("Push subscription error:", error);
      setIsLoading(false);
      return false;
    }
  }, [isPushSupported, isAuthenticated, vapidKey]);

  const unsubscribe = useCallback(async () => {
    if (!isPushSupported) return false;

    setIsLoading(true);
    try {
      if (isNative()) {
        await PushNotifications.removeAllListeners();
        setIsSubscribed(false);
        setIsLoading(false);
        return true;
      }

      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.getSubscription();

      if (subscription) {
        await subscription.unsubscribe();
        await apiRequest("DELETE", "/api/push/subscribe", {
          endpoint: subscription.endpoint,
        });
      }

      setIsSubscribed(false);
      setIsLoading(false);
      return true;
    } catch (error) {
      console.error("Push unsubscribe error:", error);
      setIsLoading(false);
      return false;
    }
  }, [isPushSupported]);

  return {
    isPushSupported,
    permission,
    isSubscribed,
    isLoading,
    subscribe,
    unsubscribe,
  };
}

// Group push notifications hook (keep web-only for now - anonymous users)
interface UseGroupPushNotificationsOptions {
  groupId: string;
  memberId: string;
}

export function useGroupPushNotifications({ groupId, memberId }: UseGroupPushNotificationsOptions) {
  const [permission, setPermission] = useState<PermissionState>("default");
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [vapidKey, setVapidKey] = useState<string | null>(null);

  const isPushSupported = typeof window !== "undefined" &&
    "serviceWorker" in navigator &&
    "PushManager" in window;

  useEffect(() => {
    if (!isPushSupported) {
      setPermission("unsupported");
      return;
    }

    setPermission(Notification.permission as PermissionState);

    if (groupId) {
      fetch(`/api/groups/${groupId}/push/vapid-key`)
        .then((res) => res.json())
        .then((data) => setVapidKey(data.vapidKey))
        .catch(() => {});
    }
  }, [isPushSupported, groupId]);

  const subscribe = useCallback(async () => {
    if (!isPushSupported || !groupId || !memberId || !vapidKey) return false;

    setIsLoading(true);
    try {
      const result = await Notification.requestPermission();
      setPermission(result as PermissionState);

      if (result !== "granted") {
        setIsLoading(false);
        return false;
      }

      const registration = await navigator.serviceWorker.register("/sw.js");
      await navigator.serviceWorker.ready;

      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(vapidKey),
      });

      const subscriptionJson = subscription.toJSON();
      await apiRequest("POST", `/api/groups/${groupId}/push/subscribe`, {
        memberId,
        subscription: {
          endpoint: subscriptionJson.endpoint,
          keys: {
            p256dh: subscriptionJson.keys?.p256dh,
            auth: subscriptionJson.keys?.auth,
          },
        },
      });

      setIsSubscribed(true);
      setIsLoading(false);
      return true;
    } catch (error) {
      console.error("Group push subscription error:", error);
      setIsLoading(false);
      return false;
    }
  }, [isPushSupported, groupId, memberId, vapidKey]);

  return {
    isPushSupported,
    permission,
    isSubscribed,
    isLoading,
    subscribe,
  };
}
```

**Step 2: Add native push token endpoint on the backend**

Add a new endpoint in `server/routes.ts` to accept native push tokens (APNs/FCM). This can be a simple storage endpoint for now — sending native push notifications requires Firebase Cloud Messaging setup which is a separate step.

In `server/routes.ts`, after the existing push routes, add:

```typescript
app.post("/api/push/subscribe-native", isAuthenticated, async (req, res) => {
  try {
    const userId = (req as any).user.id;
    const { token, platform } = req.body;
    if (!token || !platform) {
      res.status(400).json({ error: "Token and platform required" });
      return;
    }
    // Store native push token for future FCM/APNs integration
    // For now, just log it — full native push sending requires Firebase setup
    console.log(`Native push token registered: user=${userId} platform=${platform} token=${token.substring(0, 20)}...`);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: "Failed to register push token" });
  }
});
```

**Step 3: Commit**

```bash
git add client/src/hooks/use-push-notifications.ts server/routes.ts
git commit -m "feat: add native push notification support via Capacitor"
```

---

### Task 9: Replace window.open with Capacitor Browser

On native, `window.open` doesn't work well. Use Capacitor's in-app browser for Yelp links, Google Maps, DoorDash, etc.

**Files:**
- Create: `client/src/lib/open-url.ts`
- Modify: `client/src/pages/matches.tsx`
- Modify: `client/src/components/swipe-card.tsx`

**Step 1: Create the open-url utility**

```typescript
import { isNative } from "./platform";
import { Browser } from "@capacitor/browser";

/**
 * Open a URL in the appropriate way for the current platform.
 * Native: opens in-app browser. Web: opens new tab.
 */
export async function openUrl(url: string): Promise<void> {
  if (isNative()) {
    await Browser.open({ url });
  } else {
    window.open(url, "_blank");
  }
}
```

**Step 2: Update matches.tsx**

Add import at top:

```typescript
import { openUrl } from "@/lib/open-url";
```

Replace all `window.open(...)` calls with `openUrl(...)`:

1. Google Maps directions (around line 313):
```typescript
openUrl(`https://www.google.com/maps/dir/?api=1&destination=${destination}`);
```

2. DoorDash (around line 340):
```typescript
openUrl(`https://www.doordash.com/search/store/${query}/`);
```

3. Yelp reserve (around line 350):
```typescript
openUrl(restaurant.yelpUrl);
```

4. Calendar (around line 360):
```typescript
openUrl(generateCalendarUrl(restaurant, group.name));
```

**Step 3: Update swipe-card.tsx**

In the detail overlay, the "View on Yelp" button uses an `<a>` tag. Update it to use `openUrl`:

Add import:
```typescript
import { openUrl } from "@/lib/open-url";
```

Replace the Yelp link `<a>` tag with a button:
```tsx
{restaurant.yelpUrl && (
  <Button
    variant="outline"
    size="sm"
    className="w-full"
    onClick={() => openUrl(restaurant.yelpUrl!)}
  >
    <ExternalLink className="w-4 h-4 mr-2" />
    View on Yelp
  </Button>
)}
```

**Step 4: Commit**

```bash
git add client/src/lib/open-url.ts client/src/pages/matches.tsx client/src/components/swipe-card.tsx
git commit -m "feat: use in-app browser for external links on native"
```

---

### Task 10: Add native share sheet

Replace clipboard-based sharing with native share sheet on mobile.

**Files:**
- Modify: `client/src/pages/matches.tsx`

**Step 1: Update handleShare to use Capacitor Share**

Add import at top:

```typescript
import { isNative } from "@/lib/platform";
import { Share } from "@capacitor/share";
```

Update the `handleShare` function (around line 137):

```typescript
const handleShare = useCallback(async (restaurant: Restaurant) => {
  const rating = (restaurant.combinedRating ?? restaurant.rating).toFixed(1);
  const inviteCode = (group as any)?.inviteCode;
  const shareUrl = inviteCode
    ? `${window.location.origin}/crew/join/${inviteCode}`
    : window.location.origin;
  const shareText = `We matched on ${restaurant.name} (${rating} stars, ${restaurant.cuisine}, ${restaurant.priceRange}) on ChickenTinders!${inviteCode ? " Join our crew:" : ""}`;

  if (isNative()) {
    try {
      await Share.share({
        title: `${restaurant.name} - ChickenTinders Match!`,
        text: shareText,
        url: shareUrl,
        dialogTitle: "Share your match",
      });
    } catch {
      // User cancelled share - that's fine
    }
  } else if (navigator.share) {
    try {
      await navigator.share({
        title: `${restaurant.name} - ChickenTinders Match!`,
        text: shareText,
        url: shareUrl,
      });
    } catch {
    }
  } else {
    try {
      await navigator.clipboard.writeText(`${shareText}\n${shareUrl}`);
      toast({
        title: "Copied to clipboard!",
        description: "Share the link with your friends.",
      });
    } catch {
      toast({
        title: "Couldn't share",
        description: "Try copying the link manually.",
        variant: "destructive",
      });
    }
  }
}, [group, toast]);
```

**Step 2: Commit**

```bash
git add client/src/pages/matches.tsx
git commit -m "feat: use native share sheet on mobile devices"
```

---

### Task 11: Configure status bar and safe areas for native

On native, the status bar overlaps the app content. Configure it properly.

**Files:**
- Modify: `client/src/App.tsx`
- Modify: `client/src/index.css` (minor tweaks if needed)

**Step 1: Add status bar configuration in App.tsx**

Add imports:

```typescript
import { isNative, isIOS } from "@/lib/platform";
import { StatusBar, Style } from "@capacitor/status-bar";
```

Inside the `App` component, add a useEffect before the return:

```typescript
useEffect(() => {
  if (isNative()) {
    // Make status bar transparent so our gradient header shows through
    StatusBar.setStyle({ style: Style.Light });
    if (!isIOS()) {
      StatusBar.setBackgroundColor({ color: "#00000000" }); // Transparent (Android only)
      StatusBar.setOverlaysWebView({ overlay: true });
    }
  }
}, []);
```

The existing CSS already handles safe areas with `safe-top`, `safe-bottom`, `safe-x` classes and `env(safe-area-inset-*)`. These work on native too since Capacitor's WebView respects them.

**Step 2: Commit**

```bash
git add client/src/App.tsx
git commit -m "feat: configure native status bar for transparent overlay"
```

---

### Task 12: Handle deep links for crew invites

On native, `chickentinders://crew/join/ABC123` and Universal Links (`https://chickentinders.com/crew/join/ABC123`) should open the app directly.

**Files:**
- Modify: `client/src/App.tsx`

**Step 1: Add deep link listener in App.tsx**

Add import:

```typescript
import { App as CapApp, URLOpenListenerEvent } from "@capacitor/app";
```

Add deep link handling inside the `App` component's existing `useEffect` or add a new one:

```typescript
useEffect(() => {
  if (!isNative()) return;

  // Handle deep links when app is already open
  const listener = CapApp.addListener("appUrlOpen", (event: URLOpenListenerEvent) => {
    // Parse the URL path from the deep link
    // Examples:
    //   https://chickentinders.com/crew/join/ABC123
    //   chickentinders://crew/join/ABC123
    const url = new URL(event.url);
    const path = url.pathname || url.href.replace(/^[^/]*:\/\//, "/");

    if (path && path !== "/") {
      // Use wouter navigation
      window.location.hash = "";
      window.history.pushState(null, "", path);
      window.dispatchEvent(new PopStateEvent("popstate"));
    }
  });

  return () => {
    listener.then(l => l.remove());
  };
}, []);
```

**Step 2: Configure iOS Universal Links**

In `ios/App/App/Info.plist`, you'll need to add Associated Domains. This requires:
1. Your domain to host an `apple-app-site-association` file
2. The entitlement added in Xcode

For now, add a comment in the config noting this is needed for production. The custom URL scheme (`chickentinders://`) works out of the box.

Update `capacitor.config.ts` to add the custom URL scheme:

```typescript
// Add to the config object:
  plugins: {
    // ... existing plugin config ...
  },
  // Add app URL scheme
  appUrlScheme: "chickentinders",
```

**Step 3: Commit**

```bash
git add client/src/App.tsx capacitor.config.ts
git commit -m "feat: add deep link handling for crew invite URLs"
```

---

### Task 13: Hide PWA install prompt on native

The PWA install prompt shouldn't show when running inside a native app.

**Files:**
- Modify: `client/src/components/pwa-install-prompt.tsx`

**Step 1: Add early return for native**

At the top of the `PWAInstallPrompt` component, add:

```typescript
import { isNative } from "@/lib/platform";
```

Then as the first line inside the component:

```typescript
if (isNative()) return null;
```

**Step 2: Also skip service worker registration on native**

In `client/src/main.tsx`, wrap the service worker registration:

```typescript
import { isNative } from "./lib/platform";

// Only register service worker on web (native handles push/caching natively)
if (!isNative() && 'serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered:', registration.scope);
      })
      .catch((error) => {
        console.log('SW registration failed:', error);
      });
  });
}
```

**Step 3: Commit**

```bash
git add client/src/components/pwa-install-prompt.tsx client/src/main.tsx
git commit -m "feat: hide PWA install prompt and skip service worker on native"
```

---

### Task 14: Generate app icons and splash screens

Generate properly sized app icons for iOS and Android from the existing logo.

**Files:**
- Modify: `ios/App/App/Assets.xcassets/AppIcon.appiconset/`
- Modify: `android/app/src/main/res/`

**Step 1: Install capacitor-assets tool**

```bash
npm install -D @capacitor/assets
```

**Step 2: Create icon source**

The existing `client/public/icons/icon-512.png` can be used as the source. Create a `resources` directory:

```bash
mkdir -p resources
cp client/public/icons/icon-512.png resources/icon.png
cp client/public/icons/icon-512.png resources/splash.png
```

**Step 3: Generate all platform icons**

```bash
npx capacitor-assets generate --iconBackgroundColor "#1a1a2e" --splashBackgroundColor "#1a1a2e"
```

This generates:
- iOS: All required icon sizes in `ios/App/App/Assets.xcassets/AppIcon.appiconset/`
- Android: All `mipmap-*` directories with proper sizes
- Splash screens for both platforms

**Step 4: Sync**

```bash
npx cap sync
```

**Step 5: Commit**

```bash
git add resources/ ios/App/App/Assets.xcassets/ android/app/src/main/res/ package.json package-lock.json
git commit -m "feat: generate native app icons and splash screens"
```

---

### Task 15: Add keyboard handling for form inputs

On native, the keyboard can cover input fields. Capacitor's Keyboard plugin handles this.

**Files:**
- Modify: `client/src/App.tsx`

**Step 1: Add keyboard listener**

Add import:

```typescript
import { Keyboard } from "@capacitor/keyboard";
```

Add to the existing native useEffect in App.tsx:

```typescript
if (isNative()) {
  // Keyboard handling - scroll inputs into view when keyboard opens
  Keyboard.addListener("keyboardWillShow", (info) => {
    document.body.style.setProperty("--keyboard-height", `${info.keyboardHeight}px`);
  });
  Keyboard.addListener("keyboardWillHide", () => {
    document.body.style.setProperty("--keyboard-height", "0px");
  });
}
```

**Step 2: Add CSS variable usage**

In `client/src/index.css`, add:

```css
:root {
  --keyboard-height: 0px;
}
```

This makes the keyboard height available to any component that needs to adjust for it. The `capacitor.config.ts` already has `Keyboard: { resize: "body" }` which handles most cases automatically.

**Step 3: Commit**

```bash
git add client/src/App.tsx client/src/index.css
git commit -m "feat: add keyboard height tracking for native input handling"
```

---

### Task 16: Final build, sync, and verification

Build the web app and sync to native projects. Document how to open in Xcode/Android Studio.

**Files:**
- Modify: (none - this is a build/verify step)

**Step 1: Full build and sync**

```bash
npm run build
npx cap sync
```

**Step 2: Verify iOS**

```bash
npx cap open ios
```

This opens Xcode. In Xcode:
1. Select a simulator (iPhone 15 Pro recommended)
2. Click the Play button to build and run
3. Verify: app loads, swiping works with haptics, GPS works, share works, external links open in-app browser

**Step 3: Verify Android**

```bash
npx cap open android
```

This opens Android Studio. In Android Studio:
1. Select an emulator or connected device
2. Click Run to build and launch
3. Verify the same features

**Step 4: Commit final state**

```bash
git add -A
git commit -m "feat: final Capacitor sync for iOS and Android builds"
```

---

## Summary

| Task | What | Files |
|------|------|-------|
| 1 | Initialize Capacitor | capacitor.config.ts, package.json |
| 2 | Add iOS + Android platforms | ios/, android/, .gitignore |
| 3 | Platform detection utility | client/src/lib/platform.ts |
| 4 | API URL for native | queryClient.ts, swipe.tsx, group-lobby.tsx |
| 5 | Install native plugins | package.json |
| 6 | Haptic feedback on swipes | swipe-card.tsx |
| 7 | Capacitor Geolocation | preferences.tsx |
| 8 | Native push notifications | use-push-notifications.ts, routes.ts |
| 9 | In-app browser | open-url.ts, matches.tsx, swipe-card.tsx |
| 10 | Native share sheet | matches.tsx |
| 11 | Status bar config | App.tsx |
| 12 | Deep links | App.tsx, capacitor.config.ts |
| 13 | Hide PWA on native | pwa-install-prompt.tsx, main.tsx |
| 14 | App icons + splash | resources/, ios/, android/ |
| 15 | Keyboard handling | App.tsx, index.css |
| 16 | Final build + verify | Build/sync step |
